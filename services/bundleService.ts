import JSZip from 'jszip';
import { GeneratedDoc } from '../types';

// ═══════════════════════════════════════════════════════════════
// Bundle Service - Client-side utilities for bundle generation
// ═══════════════════════════════════════════════════════════════

export interface BundleDocument {
  topic: string;
  content: string;
  sources: Array<{ title: string; url: string }>;
  createdAt: number;
  position: number;
}

export interface CollectionInfo {
  name: string;
  description?: string;
}

export interface ClientBundleOptions {
  includeToc: boolean;
  includeMetadata: boolean;
  brandingTitle?: string;
  brandingLogo?: string;
  brandingColors?: {
    primary: string;
    secondary: string;
    background: string;
  };
  pageBreaks?: boolean;
}

// ═══════════════════════════════════════════════════════════════
// ZIP Bundle Generation
// ═══════════════════════════════════════════════════════════════

export async function generateZipBundle(
  collection: CollectionInfo,
  documents: BundleDocument[],
  options: ClientBundleOptions
): Promise<Blob> {
  const zip = new JSZip();

  // Sort documents by position
  const sortedDocs = [...documents].sort((a, b) => a.position - b.position);

  // Add README
  const readme = generateReadme(collection, sortedDocs, options);
  zip.file('README.md', readme);

  // Add documents folder
  const docsFolder = zip.folder('documents');
  if (docsFolder) {
    sortedDocs.forEach((doc, index) => {
      const filename = `${String(index + 1).padStart(2, '0')}-${sanitizeFilename(doc.topic)}.md`;
      const content = generateDocumentMarkdown(doc, options);
      docsFolder.file(filename, content);
    });
  }

  // Add metadata JSON
  const metadata = {
    collection: {
      name: collection.name,
      description: collection.description,
    },
    documents: sortedDocs.map((doc, index) => ({
      index: index + 1,
      topic: doc.topic,
      createdAt: new Date(doc.createdAt).toISOString(),
      sourceCount: doc.sources.length,
    })),
    generated: new Date().toISOString(),
    generator: 'DocuSynth AI',
  };
  zip.file('metadata.json', JSON.stringify(metadata, null, 2));

  // Generate combined markdown if includeToc
  if (options.includeToc) {
    const combined = generateCombinedMarkdown(collection, sortedDocs, options);
    zip.file('combined.md', combined);
  }

  return await zip.generateAsync({ type: 'blob' });
}

// ═══════════════════════════════════════════════════════════════
// Combined Markdown Generation
// ═══════════════════════════════════════════════════════════════

export function generateCombinedMarkdown(
  collection: CollectionInfo,
  documents: BundleDocument[],
  options: ClientBundleOptions
): string {
  const sortedDocs = [...documents].sort((a, b) => a.position - b.position);
  let content = '';

  // Header
  content += `# ${options.brandingTitle || collection.name}\n\n`;
  if (collection.description) {
    content += `${collection.description}\n\n`;
  }

  // Table of Contents
  if (options.includeToc && sortedDocs.length > 0) {
    content += `## Table of Contents\n\n`;
    sortedDocs.forEach((doc, i) => {
      const anchor = doc.topic
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '');
      content += `${i + 1}. [${doc.topic}](#${anchor})\n`;
    });
    content += '\n---\n\n';
  }

  // Documents
  sortedDocs.forEach((doc, i) => {
    if (options.pageBreaks && i > 0) {
      content += '\n<div style="page-break-before: always;"></div>\n\n';
    }

    content += `## ${doc.topic}\n\n`;

    if (options.includeMetadata) {
      content += `*Created: ${new Date(doc.createdAt).toLocaleDateString()}*\n\n`;
    }

    content += doc.content + '\n\n';

    if (options.includeMetadata && doc.sources.length > 0) {
      content += `### Sources\n\n`;
      doc.sources.forEach((source) => {
        content += `- [${source.title}](${source.url})\n`;
      });
      content += '\n';
    }

    content += '---\n\n';
  });

  // Footer
  content += `\n*Generated by DocuSynth AI on ${new Date().toLocaleString()}*\n`;

  return content;
}

// ═══════════════════════════════════════════════════════════════
// PDF HTML Generation (for client-side PDF conversion)
// ═══════════════════════════════════════════════════════════════

export function generatePdfHtml(
  collection: CollectionInfo,
  documents: BundleDocument[],
  options: ClientBundleOptions
): string {
  const sortedDocs = [...documents].sort((a, b) => a.position - b.position);
  const colors = options.brandingColors || {
    primary: '#6366f1',
    secondary: '#64748b',
    background: '#ffffff',
  };

  let html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${escapeHtml(collection.name)}</title>
  <style>
    @media print {
      .page-break { page-break-before: always; }
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #1a1a2e;
      background: ${colors.background};
      max-width: 800px;
      margin: 0 auto;
      padding: 40px;
    }
    h1 { color: ${colors.primary}; border-bottom: 2px solid ${colors.primary}; padding-bottom: 10px; }
    h2 { color: ${colors.primary}; margin-top: 2em; }
    h3 { color: ${colors.secondary}; }
    a { color: ${colors.primary}; }
    code { background: #f4f4f5; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
    pre { background: #1a1a2e; color: #e4e4e7; padding: 16px; border-radius: 8px; overflow-x: auto; }
    pre code { background: transparent; color: inherit; }
    blockquote { border-left: 4px solid ${colors.primary}; margin: 0; padding-left: 16px; color: ${colors.secondary}; }
    .toc { background: #f8fafc; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
    .toc ul { list-style: none; padding-left: 0; }
    .toc li { margin: 8px 0; }
    .metadata { color: ${colors.secondary}; font-size: 0.9em; margin-bottom: 1em; }
    .sources { background: #f8fafc; padding: 16px; border-radius: 8px; margin-top: 2em; }
    .sources ul { margin: 0; padding-left: 20px; }
  </style>
</head>
<body>
`;

  // Header with optional branding
  if (options.brandingLogo) {
    html += `<img src="${options.brandingLogo}" alt="Logo" style="max-height: 60px; margin-bottom: 20px;" />\n`;
  }

  html += `<h1>${escapeHtml(options.brandingTitle || collection.name)}</h1>\n`;

  if (collection.description) {
    html += `<p>${escapeHtml(collection.description)}</p>\n`;
  }

  // Table of Contents
  if (options.includeToc && sortedDocs.length > 0) {
    html += `<div class="toc">\n<h2>Table of Contents</h2>\n<ul>\n`;
    sortedDocs.forEach((doc, i) => {
      html += `<li>${i + 1}. ${escapeHtml(doc.topic)}</li>\n`;
    });
    html += `</ul>\n</div>\n`;
  }

  // Documents
  sortedDocs.forEach((doc, i) => {
    if (options.pageBreaks && i > 0) {
      html += `<div class="page-break"></div>\n`;
    }

    html += `<h2>${escapeHtml(doc.topic)}</h2>\n`;

    if (options.includeMetadata) {
      html += `<p class="metadata">Created: ${new Date(doc.createdAt).toLocaleDateString()}</p>\n`;
    }

    html += markdownToHtml(doc.content) + '\n';

    if (options.includeMetadata && doc.sources.length > 0) {
      html += `<div class="sources">\n<h3>Sources</h3>\n<ul>\n`;
      doc.sources.forEach((source) => {
        html += `<li><a href="${escapeHtml(source.url)}">${escapeHtml(source.title)}</a></li>\n`;
      });
      html += `</ul>\n</div>\n`;
    }
  });

  // Footer
  html += `<hr style="margin-top: 40px;" />\n`;
  html += `<p style="color: ${colors.secondary}; font-size: 0.8em; text-align: center;">`;
  html += `Generated by DocuSynth AI on ${new Date().toLocaleString()}</p>\n`;

  html += `</body>\n</html>`;

  return html;
}

// ═══════════════════════════════════════════════════════════════
// Table of Contents Generation
// ═══════════════════════════════════════════════════════════════

export interface TocEntry {
  level: number;
  text: string;
  anchor: string;
}

export function extractTableOfContents(markdown: string, maxDepth: number = 3): TocEntry[] {
  const entries: TocEntry[] = [];
  const lines = markdown.split('\n');

  for (const line of lines) {
    const match = line.match(/^(#{1,6})\s+(.+)$/);
    if (match) {
      const level = match[1].length;
      if (level <= maxDepth) {
        const text = match[2].trim();
        const anchor = text
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-|-$/g, '');
        entries.push({ level, text, anchor });
      }
    }
  }

  return entries;
}

export function generateTocMarkdown(entries: TocEntry[]): string {
  let toc = '';
  for (const entry of entries) {
    const indent = '  '.repeat(entry.level - 1);
    toc += `${indent}- [${entry.text}](#${entry.anchor})\n`;
  }
  return toc;
}

// ═══════════════════════════════════════════════════════════════
// Helper Functions
// ═══════════════════════════════════════════════════════════════

function generateReadme(
  collection: CollectionInfo,
  documents: BundleDocument[],
  options: ClientBundleOptions
): string {
  let content = `# ${options.brandingTitle || collection.name}\n\n`;

  if (collection.description) {
    content += `${collection.description}\n\n`;
  }

  content += `## Contents\n\n`;
  content += `This bundle contains ${documents.length} document(s):\n\n`;

  documents.forEach((doc, i) => {
    content += `${i + 1}. **${doc.topic}**\n`;
    if (options.includeMetadata) {
      content += `   - Created: ${new Date(doc.createdAt).toLocaleDateString()}\n`;
      content += `   - Sources: ${doc.sources.length}\n`;
    }
  });

  content += `\n## File Structure\n\n`;
  content += `\`\`\`\n`;
  content += `${sanitizeFilename(collection.name)}/\n`;
  content += `  README.md           # This file\n`;
  content += `  metadata.json       # Collection metadata\n`;
  if (options.includeToc) {
    content += `  combined.md         # All documents combined\n`;
  }
  content += `  documents/          # Individual documents\n`;
  documents.forEach((doc, i) => {
    const filename = `${String(i + 1).padStart(2, '0')}-${sanitizeFilename(doc.topic)}.md`;
    content += `    ${filename}\n`;
  });
  content += `\`\`\`\n\n`;

  content += `## Generated\n\n`;
  content += `This bundle was generated by DocuSynth AI on ${new Date().toLocaleString()}.\n`;

  return content;
}

function generateDocumentMarkdown(doc: BundleDocument, options: ClientBundleOptions): string {
  let content = `# ${doc.topic}\n\n`;

  if (options.includeMetadata) {
    content += `*Created: ${new Date(doc.createdAt).toLocaleDateString()}*\n\n`;
  }

  content += doc.content + '\n\n';

  if (options.includeMetadata && doc.sources.length > 0) {
    content += `## Sources\n\n`;
    doc.sources.forEach((source) => {
      content += `- [${source.title}](${source.url})\n`;
    });
  }

  return content;
}

function sanitizeFilename(name: string): string {
  return name
    .replace(/[^a-z0-9\s-]/gi, '')
    .replace(/\s+/g, '-')
    .toLowerCase()
    .slice(0, 50);
}

function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

function markdownToHtml(markdown: string): string {
  // Basic markdown to HTML conversion
  let html = markdown
    // Code blocks
    .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
    // Inline code
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    // Headers (demote since we use h2 for doc titles)
    .replace(/^### (.*$)/gm, '<h4>$1</h4>')
    .replace(/^## (.*$)/gm, '<h3>$1</h3>')
    .replace(/^# (.*$)/gm, '<h3>$1</h3>')
    // Bold
    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
    // Italic
    .replace(/\*([^*]+)\*/g, '<em>$1</em>')
    // Links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
    // Blockquotes
    .replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>')
    // Lists
    .replace(/^- (.*$)/gm, '<li>$1</li>')
    .replace(/^\d+\. (.*$)/gm, '<li>$1</li>')
    // Paragraphs
    .replace(/\n\n/g, '</p><p>')
    .replace(/\n/g, '<br />');

  // Wrap in paragraph tags
  html = '<p>' + html + '</p>';

  // Clean up empty paragraphs
  html = html.replace(/<p>\s*<\/p>/g, '');

  return html;
}

// ═══════════════════════════════════════════════════════════════
// Download Utilities
// ═══════════════════════════════════════════════════════════════

export function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export function downloadText(content: string, filename: string, mimeType: string = 'text/plain'): void {
  const blob = new Blob([content], { type: mimeType });
  downloadBlob(blob, filename);
}

export async function downloadFromUrl(url: string, filename: string): Promise<void> {
  try {
    const response = await fetch(url);
    const blob = await response.blob();
    downloadBlob(blob, filename);
  } catch (error) {
    console.error('Download failed:', error);
    throw new Error('Failed to download file');
  }
}

// ═══════════════════════════════════════════════════════════════
// Data URL Utilities
// ═══════════════════════════════════════════════════════════════

export function dataUrlToBlob(dataUrl: string): Blob {
  const parts = dataUrl.split(',');
  const mimeMatch = parts[0].match(/:(.*?);/);
  const mime = mimeMatch ? mimeMatch[1] : 'text/plain';
  const bstr = atob(parts[1]);
  const n = bstr.length;
  const u8arr = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    u8arr[i] = bstr.charCodeAt(i);
  }
  return new Blob([u8arr], { type: mime });
}

export function stringToDataUrl(content: string, mimeType: string = 'text/plain'): string {
  return `data:${mimeType};base64,${btoa(unescape(encodeURIComponent(content)))}`;
}
