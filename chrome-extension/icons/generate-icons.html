<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DocuSynth AI Icon Generator</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 40px;
      background: #f8fafc;
      max-width: 800px;
      margin: 0 auto;
    }
    h1 {
      color: #0f172a;
      margin-bottom: 8px;
    }
    p {
      color: #64748b;
      margin-bottom: 32px;
    }
    .icons {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
      margin-bottom: 32px;
    }
    .icon-preview {
      text-align: center;
    }
    .icon-preview canvas {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 8px;
    }
    .icon-preview span {
      display: block;
      font-size: 12px;
      color: #64748b;
    }
    button {
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 500;
      color: white;
      background: linear-gradient(135deg, #3b82f6, #6366f1);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-right: 12px;
    }
    button:hover {
      opacity: 0.9;
    }
    .instructions {
      margin-top: 32px;
      padding: 20px;
      background: white;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    .instructions h3 {
      margin-top: 0;
      color: #0f172a;
    }
    .instructions ol {
      color: #475569;
      padding-left: 20px;
    }
    .instructions li {
      margin-bottom: 8px;
    }
    code {
      background: #f1f5f9;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <h1>DocuSynth AI Icon Generator</h1>
  <p>Generate extension icons for the DocuSynth AI Chrome extension</p>

  <div class="icons" id="icons"></div>

  <button onclick="downloadAll()">Download All Icons</button>
  <button onclick="downloadZip()">Download as ZIP</button>

  <div class="instructions">
    <h3>Instructions</h3>
    <ol>
      <li>Click "Download All Icons" to download each icon individually</li>
      <li>Or click "Download as ZIP" to get all icons in one file</li>
      <li>Place the downloaded PNG files in the <code>icons/</code> folder</li>
      <li>Reload the extension in <code>chrome://extensions</code></li>
    </ol>
  </div>

  <script>
    const sizes = [16, 32, 48, 128];
    const iconContainer = document.getElementById('icons');

    function drawIcon(canvas, size) {
      const ctx = canvas.getContext('2d');
      canvas.width = size;
      canvas.height = size;

      // Create gradient background
      const gradient = ctx.createLinearGradient(0, 0, size, size);
      gradient.addColorStop(0, '#3b82f6');
      gradient.addColorStop(1, '#6366f1');

      // Draw rounded rectangle background
      const radius = size * 0.18;
      ctx.beginPath();
      ctx.moveTo(radius, 0);
      ctx.lineTo(size - radius, 0);
      ctx.quadraticCurveTo(size, 0, size, radius);
      ctx.lineTo(size, size - radius);
      ctx.quadraticCurveTo(size, size, size - radius, size);
      ctx.lineTo(radius, size);
      ctx.quadraticCurveTo(0, size, 0, size - radius);
      ctx.lineTo(0, radius);
      ctx.quadraticCurveTo(0, 0, radius, 0);
      ctx.closePath();
      ctx.fillStyle = gradient;
      ctx.fill();

      // Draw document icon
      ctx.fillStyle = 'white';
      const docMargin = size * 0.22;
      const docWidth = size * 0.42;
      const docHeight = size * 0.56;
      const foldSize = size * 0.12;

      ctx.beginPath();
      ctx.moveTo(docMargin, docMargin);
      ctx.lineTo(docMargin + docWidth - foldSize, docMargin);
      ctx.lineTo(docMargin + docWidth, docMargin + foldSize);
      ctx.lineTo(docMargin + docWidth, docMargin + docHeight);
      ctx.lineTo(docMargin, docMargin + docHeight);
      ctx.closePath();
      ctx.fill();

      // Draw fold
      ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
      ctx.beginPath();
      ctx.moveTo(docMargin + docWidth - foldSize, docMargin);
      ctx.lineTo(docMargin + docWidth - foldSize, docMargin + foldSize);
      ctx.lineTo(docMargin + docWidth, docMargin + foldSize);
      ctx.closePath();
      ctx.fill();

      // Draw lines on document
      ctx.fillStyle = '#3b82f6';
      const lineMargin = docMargin + size * 0.06;
      const lineWidth = docWidth - size * 0.12;
      const lineHeight = Math.max(1, size * 0.04);
      const lineGap = size * 0.08;

      for (let i = 0; i < 3; i++) {
        const lineY = docMargin + size * 0.18 + i * lineGap;
        const currentLineWidth = i === 2 ? lineWidth * 0.6 : lineWidth;
        ctx.fillRect(lineMargin, lineY, currentLineWidth, lineHeight);
      }

      // Draw AI sparkle/lightning bolt
      ctx.fillStyle = 'white';
      const boltX = size * 0.58;
      const boltY = size * 0.45;
      const boltSize = size * 0.35;

      ctx.beginPath();
      ctx.moveTo(boltX + boltSize * 0.5, boltY);
      ctx.lineTo(boltX + boltSize * 0.15, boltY + boltSize * 0.45);
      ctx.lineTo(boltX + boltSize * 0.4, boltY + boltSize * 0.45);
      ctx.lineTo(boltX + boltSize * 0.25, boltY + boltSize * 0.85);
      ctx.lineTo(boltX + boltSize * 0.7, boltY + boltSize * 0.35);
      ctx.lineTo(boltX + boltSize * 0.45, boltY + boltSize * 0.35);
      ctx.closePath();
      ctx.fill();

      return canvas;
    }

    // Generate previews
    sizes.forEach(size => {
      const preview = document.createElement('div');
      preview.className = 'icon-preview';

      const canvas = document.createElement('canvas');
      drawIcon(canvas, size);

      const displaySize = Math.max(size, 48);
      canvas.style.width = displaySize + 'px';
      canvas.style.height = displaySize + 'px';

      const label = document.createElement('span');
      label.textContent = `icon${size}.png (${size}x${size})`;

      preview.appendChild(canvas);
      preview.appendChild(label);
      iconContainer.appendChild(preview);
    });

    function downloadAll() {
      sizes.forEach(size => {
        const canvas = document.createElement('canvas');
        drawIcon(canvas, size);

        const link = document.createElement('a');
        link.download = `icon${size}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
      });
    }

    async function downloadZip() {
      // Simple inline ZIP implementation for small files
      const files = [];

      for (const size of sizes) {
        const canvas = document.createElement('canvas');
        drawIcon(canvas, size);

        const dataUrl = canvas.toDataURL('image/png');
        const base64 = dataUrl.split(',')[1];
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }

        files.push({
          name: `icon${size}.png`,
          data: bytes
        });
      }

      // Create ZIP file
      const zip = createZip(files);
      const blob = new Blob([zip], { type: 'application/zip' });
      const url = URL.createObjectURL(blob);

      const link = document.createElement('a');
      link.download = 'docusynth-icons.zip';
      link.href = url;
      link.click();

      URL.revokeObjectURL(url);
    }

    // Simple ZIP file creator
    function createZip(files) {
      const localHeaders = [];
      const centralHeaders = [];
      let offset = 0;

      for (const file of files) {
        const nameBytes = new TextEncoder().encode(file.name);
        const crc = crc32(file.data);

        // Local file header
        const local = new Uint8Array(30 + nameBytes.length + file.data.length);
        const localView = new DataView(local.buffer);

        localView.setUint32(0, 0x04034b50, true); // Signature
        localView.setUint16(4, 20, true); // Version
        localView.setUint16(6, 0, true); // Flags
        localView.setUint16(8, 0, true); // Compression
        localView.setUint16(10, 0, true); // Mod time
        localView.setUint16(12, 0, true); // Mod date
        localView.setUint32(14, crc, true); // CRC
        localView.setUint32(18, file.data.length, true); // Compressed size
        localView.setUint32(22, file.data.length, true); // Uncompressed size
        localView.setUint16(26, nameBytes.length, true); // Name length
        localView.setUint16(28, 0, true); // Extra length

        local.set(nameBytes, 30);
        local.set(file.data, 30 + nameBytes.length);
        localHeaders.push(local);

        // Central directory header
        const central = new Uint8Array(46 + nameBytes.length);
        const centralView = new DataView(central.buffer);

        centralView.setUint32(0, 0x02014b50, true); // Signature
        centralView.setUint16(4, 20, true); // Version made by
        centralView.setUint16(6, 20, true); // Version needed
        centralView.setUint16(8, 0, true); // Flags
        centralView.setUint16(10, 0, true); // Compression
        centralView.setUint16(12, 0, true); // Mod time
        centralView.setUint16(14, 0, true); // Mod date
        centralView.setUint32(16, crc, true); // CRC
        centralView.setUint32(20, file.data.length, true); // Compressed size
        centralView.setUint32(24, file.data.length, true); // Uncompressed size
        centralView.setUint16(28, nameBytes.length, true); // Name length
        centralView.setUint16(30, 0, true); // Extra length
        centralView.setUint16(32, 0, true); // Comment length
        centralView.setUint16(34, 0, true); // Disk start
        centralView.setUint16(36, 0, true); // Internal attrs
        centralView.setUint32(38, 0, true); // External attrs
        centralView.setUint32(42, offset, true); // Offset

        central.set(nameBytes, 46);
        centralHeaders.push(central);

        offset += local.length;
      }

      const centralStart = offset;
      const centralSize = centralHeaders.reduce((a, b) => a + b.length, 0);

      // End of central directory
      const end = new Uint8Array(22);
      const endView = new DataView(end.buffer);

      endView.setUint32(0, 0x06054b50, true); // Signature
      endView.setUint16(4, 0, true); // Disk number
      endView.setUint16(6, 0, true); // Central dir disk
      endView.setUint16(8, files.length, true); // Entries on disk
      endView.setUint16(10, files.length, true); // Total entries
      endView.setUint32(12, centralSize, true); // Central dir size
      endView.setUint32(16, centralStart, true); // Central dir offset
      endView.setUint16(20, 0, true); // Comment length

      // Combine all parts
      const totalSize = offset + centralSize + 22;
      const result = new Uint8Array(totalSize);
      let pos = 0;

      for (const local of localHeaders) {
        result.set(local, pos);
        pos += local.length;
      }

      for (const central of centralHeaders) {
        result.set(central, pos);
        pos += central.length;
      }

      result.set(end, pos);

      return result;
    }

    // CRC32 calculation
    function crc32(data) {
      const table = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
          c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        table[i] = c;
      }

      let crc = 0xFFFFFFFF;
      for (let i = 0; i < data.length; i++) {
        crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
      }
      return (crc ^ 0xFFFFFFFF) >>> 0;
    }
  </script>
</body>
</html>
